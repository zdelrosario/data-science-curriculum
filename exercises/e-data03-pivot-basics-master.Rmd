---
title: "Pivoting Data"
author: Zachary del Rosario
date: 2020-05-07
output: github_document
time: 40
reading: 0
---

# Data: Pivoting Data

*Purpose*: Data is easiest to use when it is *tidy*. In fact, the tidyverse (including ggplot, dplyr, etc.) is specifically designed to use tidy data. But not all data we'll encounter is tidy! To that end, in this exercise we'll learn how to tidy our data by *pivoting*.

As a result of learning how to quickly *tidy* data, you'll vastly expand the set of datasets you can analyze. Rather than fighting with data, you'll be able to quickly wrangle and extract insights.

*Reading*: (None, this is the reading)

```{r setup, include=FALSE}
# knitr options
knitr::opts_chunk$set(echo = TRUE)
```

```{r library}
library(tidyverse)
```

## Tidy Data

Tidy data is a form of data where:

1. Each *variable* is in its own *column*
2. Each *observation* is in its own *row*
3. Each *value* is in its own *cell*

*Optional reading:* [Tidy Data](https://openscapes.org/blog/2020-10-12-tidy-data/), by Julie Lowndes and Allison Horst.

Not all data are presented in tidy form; in this case it can be difficult to tell what the variables are. Let's practice distinguishing between the *columns* and the *variables*.

### __q1__ What are the variables in the following dataset?

```{r cases-setup}
## NOTE: No need to edit; execute
cases <- tribble(
  ~Country, ~`2011`, ~`2012`, ~`2013`,
      "FR",    7000,    6900,    7000,
      "DE",    5800,    6000,    6200,
      "US",   15000,   14000,   13000
)
cases
```

- 1. Country, 2011, 2012, and 2013
- 2. Country, year, and some unknown quantity (n, count, etc.)
- 3. FR, DE, and US

```{r q1-test}
## TODO: Modify with your multiple choice number answer
q1_answer <- 0

## NOTE: The following will test your answer
if (((q1_answer + 56) %% 3 == 1) & (q1_answer > 0)) {
  "Correct!"
} else {
  "Incorrect!"
}
```

Check out the solution manual to see the reasons.
<!-- solution-begin -->
1. Incorrect: `2011` (and etc.) are values for the `year` variable.
2. Correct
3. Incorrect: "FR" (and etc.) are values for the `Country` variable
<!-- solution-end -->

### __q2__ What are the variables in the following dataset?

```{r stang-setup}
## NOTE: No need to edit; execute
alloys <- tribble(
  ~thick, ~E_00, ~mu_00, ~E_45, ~mu_45, ~rep,
   0.022, 10600,  0.321, 10700,  0.329,    1,
   0.022, 10600,  0.323, 10500,  0.331,    2,
   0.032, 10400,  0.329, 10400,  0.318,    1,
   0.032, 10300,  0.319, 10500,  0.326,    2
)
alloys
```

- 1. thick, E_00, mu_00, E_45, mu_45, rep
- 2. thick, E, mu, rep
- 3. thick, E, mu, rep, angle

```{r q2-test}
## TODO: Modify with your multiple choice number answer
q2_answer <- 0

## NOTE: The following will test your answer
if (((q2_answer + 38) %% 3 == 2) & (q2_answer > 0)) {
  "Correct!"
} else {
  "Incorrect!"
}
```

Check out the solution manual to see the reasons.
<!-- solution-begin -->
1. Incorrect: `E_00` (and etc.) are *mixed*; they contain both variable names and value
2. Incorrect: This is missing the `angle` variable
3. Correct.
<!-- solution-end -->

## Pivoting: Examples

The dplyr package comes with tools to *pivot* our data into tidy form. There are two key tools: `pivot_longer` and `pivot_wider`. The names are suggestive of their use. When our data are too wide we should `pivot_longer`, and when our data are too long, we should `pivot_wider`.

### Pivot longer

First, let's see how `pivot_longer` works on the `cases` data. Run the following code chunk:

```{r cases-demo}
## NOTE: No need to edit; execute
cases %>%
  pivot_longer(
    names_to = "Year",
    values_to = "n",
    cols = c(`2011`, `2012`, `2013`)
  )
```

Now these data are tidy! The variable `Year` is now the name of a column, and its values appear in the cells.

Let's break down the key inputs to `pivot_longer`:

- `names_to` is what we're going to call the new column whose values will be the original column names
- `values_to` is what we're going to call the new column that will hold the values associated with the original columns
- `cols` is the set of columns in the original dataset that we're going to modify. This takes the same inputs as a call to `select`, so we can use functions like `starts_with, ends_with, contains`, etc., or a list of column names enclosed with `c()`
  - Note that in our case, we had to enclose each column name with ticks so that dplyr does not interpret the integer values as column positions (rather than column names)
  - For more details on selecting variables, see the [selection language](https://tidyselect.r-lib.org/reference/language.html) page

However, there's a problem with the `Year` column:

```{r cases-problem}
## NOTE: No need to edit; execute
cases %>%
  pivot_longer(
    names_to = "Year",
    values_to = "n",
    c(`2011`, `2012`, `2013`)

  ) %>%
  summarize(Year = mean(Year))
```

The summary failed! That's because the `Year` column is full of strings, rather than integers. We can fix this via mutation:

```{r cases-problem-solved}
## NOTE: No need to edit; execute
cases %>%
  pivot_longer(
    names_to = "Year",
    values_to = "n",
    c(`2011`, `2012`, `2013`)
  ) %>%
  mutate(Year = as.integer(Year))
```

Now the data are tidy and of the proper type.

Let's look at another example:

```{r anscombe-show}
## NOTE: No need to edit; execute
ansc <-
  tribble(
    ~`x-1`, ~`x-2`, ~`y-1`, ~`y-2`,
        10,     10,   8.04,   9.14,
         8,      8,   6.95,   8.14,
        13,     13,   7.58,   8.74,
         9,      9,   8.81,   8.77,
        11,     11,   8.33,   9.26,
        14,     14,   9.96,   8.10,
         6,      6,   7.24,   6.13,
         4,      4,   4.26,   3.10,
        12,     12,  10.84,   9.13,
         7,      7,   4.82,   7.26,
         5,      5,   5.68,   4.74
  )
ansc
```

This dataset is too wide; the digit after each `x` or `y` denotes a different dataset. The case is tricky to pivot though: We need to separate the trailing digits (in the column names) while preserving the `x, y` column names. 

We can use a combination of the `names_sep` argument and the special ".value" in `names_to`:

```{r anscombe-pivot}
## NOTE: No need to edit; execute
ansc %>%
  pivot_longer(
    names_to = c(".value", "set"),
    names_sep = "-",
    cols = everything()
  )
```

Note that:
- With `.value` in `names_to`, we do *not* provide the `values_to` column names. We are instead signaling that the value names come from the existing column names
- `everything()` is a convenient way to select all columns

Let's look at one more use of `pivot_longer` on the `alloys` dataset.

```{r alloys-demo1}
## NOTE: No need to edit; execute
alloys %>%
  pivot_longer(
    names_to = c("var", "angle"),
    names_sep = "_",
    values_to = "val",
    cols = c(-thick, -rep) # Use all columns in the pivot, *EXCEPT* these two
  )
```

Note a few differences from the call of `pivot_longer` on the `cases` data:

- here `names_to` contains *two* names; this is to deal with the two components of the merged column names `E_00, mu_00, E_45,` etc.
- `names_sep` allows us to specify a character that separates the components of the merged column names. In our case, the column names are merged with an underscore `_`
- We use the `-column` syntax with `cols` to signal that we *don't* want the specified columns. This allows us to exclude `thick, rep`
  - As an alternative, we could have used the more verbose `cols = starts_with("E") | starts_with("mu")`, which means "starts with "E" OR starts with "mu""

This looks closer to tidy---we've taken care of the merged column names---but now we have a different problem: The variables `E, mu` are now in cells, rather than column names! This is an example of a dataset that is *too long*. For this, we'll need to use `pivot_wider`.

### Pivot wider

We'll continue tidying the `alloys` dataset with `pivot_wider`.

```{r alloys-demo2}
## NOTE: No need to edit; execute
alloys %>%
  pivot_longer(
    names_to = c("var", "angle"),
    names_sep = "_",
    values_to = "val",
    starts_with("E") | starts_with("mu")
  ) %>%
  pivot_wider(
    names_from = var, # Cell entries to turn into new column names
    values_from = val # Values to associate with the new column(s)
  )
```

Note the differences between `pivot_longer` and `pivot_wider`:

- Rather than `names_to`, we specify `names_from`; this takes a tidyselect specification. We specify the column(s) to turn into new column names
- Rather than `values_to`, we specify `values_from`; this takes a tidyselect specification. We specify the column(s) to turn into new values

What we just saw above is a general strategy: If you see merged column names, you can:

1. First, `pivot_longer` with `names_sep` or `names_pattern` to unmerge the column names.
2. Next, `pivot_wider` to tidy the data.

Both `pivot_longer` and `pivot_wider` have a *lot* of features; see their documentation for more info.

## Pivoting: Exercises

To practice using `pivot_longer` and `pivot_wider`, we're going to work with the following small dataset:

```{r base}
## NOTE: No need to edit; this is setup for the exercises
df_base <-
  tribble(
    ~`X-0`, ~`X-1`, ~key,
         1,      9,  "A",
         2,      8,  "B",
         3,      7,  "C"
  )
```

We're going to play a game: I'm going to modify the data, and your job is to pivot it back to equal `df_base`.

### __q3__ Unpivot the data

Recover `df_base` from `df_q3` by using a *single* pivot and no other functions.

```{r q3-setup}
## NOTE: No need to edit; this is setup for the exercise
df_q3 <-
  df_base %>%
  pivot_longer(
    names_to = "id",
    names_pattern = "(\\d)",
    names_transform = list(id = as.integer),
    values_to = "value",
    cols = -key
  )
df_q3
```

Undo the modification using a single pivot. Don't worry about column order.

*Hint*: The `names_prefix` argument will help here!

```{r q3-task}
df_q3_res <-
  df_q3 %>%
# task-begin
## NOTE: Add your pivot here!
# task-end
# solution-begin
  pivot_wider(
    names_from = id,
    names_prefix = "X-",
    values_from = value
  )
# solution-end

df_q3_res
all.equal(
  df_base, 
  df_q3_res %>% select(names(df_base))
) # Checks equality; returns TRUE if equal
```

### __q4__ Unpivot the data

Recover `df_base` from `df_q4` by using a *single* pivot and no other functions.

```{r q4-setup}
## NOTE: No need to edit; this is setup for the exercise
df_q4 <-
  df_base %>%
  pivot_wider(
    names_from = key,
    values_from = `X-0`
  )
df_q4
```

Undo the modification using a single pivot. Don't worry about column order.

*Hint*: You'll need a way to drop `NA` values in the pivot (without filtering). Check the documentation for `pivot_longer`.

```{r q4-task}
df_q4_res <-
  df_q4 %>%
# task-begin
## NOTE: Add your pivot here!
# task-end
# solution-begin
  pivot_longer(
    names_to = "key",
    values_to = "X-0",
    values_drop_na = TRUE,
    cols = c(A, B, C)
  )
# solution-end

df_q4_res
all.equal(
  df_base, 
  df_q4_res %>% select(names(df_base))
) # Checks equality; returns TRUE if equal
```

### __q5__ Unpivot the data

Recover `df_base` from `df_q5` by using a *single* pivot and no other functions.

```{r q5-setup}
## NOTE: No need to edit; this is setup for the exercise
df_q5 <-
  df_base %>%
  pivot_wider(
    names_from = key,
    values_from = -key
  )
df_q5
```

Undo the modification using a single pivot. Don't worry about column order.

*Hint*: For this one, you'll need to use the special `.value` entry in `names_to`.

```{r q5-task}
df_q5_res <-
  df_q5 %>%
# task-begin
## NOTE: Add your pivot here!
# task-end
# solution-begin
  pivot_longer(
    names_to = c(".value", "key"),
    names_sep = "_",
    cols = everything()
  )
# solution-end

df_q5_res
all.equal(
  df_base, 
  df_q5_res %>% select(names(df_base))
) # Checks equality; returns TRUE if equal
```

### __q6__ Make your own!

Using a single pivot on `df_base` create your own *challenge* dataframe. You will share this with the rest of the class as a puzzle, so make sure to solve your own challenge so you have a solution!

```{r q6-task}
## NOTE: No need to edit; this is setup for the exercise
df_q6 <-
  df_base %>%
# task-begin
## NOTE: Add your pivot here!
# task-end
# solution-begin
  glimpse()
# solution-end

df_q6
```

Don't forget to create a solution!

```{r q6-solution}
df_q6_res <-
  df_q6 %>%
# task-begin
## NOTE: Add your pivot here!
# task-end
# solution-begin
  glimpse()
# solution-end

df_q6_res
all.equal(
  df_base, 
  df_q6_res %>% select(names(df_base))
) # Checks equality; returns TRUE if equal
```

*Optional reading*:
- [selection language](https://tidyselect.r-lib.org/reference/language.html)

<!-- include-exit-ticket -->
